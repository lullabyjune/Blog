# 相对高阶的类型声明
事实使用ts的过程中，除了常规`type`, `interface`之外， 还会用到很多的关键字和内建的`type`。

## infer
`infer`真的是很好用了，谁用谁知道0-0.
也是可以有一些比较花的操作， 我这里大概介绍两个我用的比较多的

```typescript
type TReturnType<T> =  T extends (...args: any[]) => infer P ? P : never
type TParamsType<T> = T extends (...agrs: infer P) => any ? P : never

const fn = ({ a, b }: { a: string; b: string }, c: string, d: string) => 111;

let a: TReturnType<typeof fn>
let args: TParamsType<typeof fn>
```

这两个type可以分别获取到函数的返回类型和参数类型， 当然可以根据自己项目作其他的扩展， 比如`type TReturnType<T> =  T extends (...args: any[]) => infer Promise<P> ? Promise<P> : never`可以判断是不是一个异步函数0-0.

##  -
这个比较少见， 我也没找到相关的文档解释啥的。。是问其他大佬才具体知道的
```typescript
type Required<T> = {
  [K in keyof T]-?: T[K]
}
```
这个就是内置的`Required`的源码， 具体这个`-?`可以简单的理解成把`?`去掉， 因为本质上而言`?`是加在后面的， 比如
```typescript
interface A {
  a: string,
  b?: string
}

let a: A['b'] //  string | undefined
```
可以看到这个`?`实际上是给后面的`string`加上了一个`undefined`， 所以针对上面的这个`A`， `A[keyof A]`是不能把`?: string -> string`的， 因为在解析`A[keyof A]`这一步的时候实际上得到的结果就是`string | undefined`了， 所以要去掉这个`?`的话， 只能靠`-?`
但是我没测试出来`-`后面可以跟的其他的东西。。 可能是只有`-?`这一种组合吧目前。。